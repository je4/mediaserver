//go:generate swag init --parseDependency  --parseInternal -g .\api.go

package ingest

import (
	"context"
	"crypto/tls"
	"emperror.dev/errors"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/google/martian/log"
	"github.com/je4/mediaserver/v2/pkg/ingest/docs" // generated by swag cli
	"github.com/je4/mediaserver/v2/pkg/rest"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"net/http"
	"sync"
)

const BASEPATH = "/api/v1"

//	@title			Media Server Ingest API
//	@version		1.0
//	@description	Ingesting Media files
//	@termsOfService	http://swagger.io/terms/

//	@contact.name	University Library Basel, Informatik
//	@contact.url	https://ub.unibas.ch
//	@contact.email	it-ub@unibas.ch

//	@license.name	Apache 2.0
//	@license.url	http://www.apache.org/licenses/LICENSE-2.0.html

// @securityDefinitions.apikey	ApiKeyAuth
// @in							header
// @name						Authorization
// @description					Bearer Authentication with JWT

func NewController(addr string, cert *tls.Certificate) (*controller, error) {

	// programmatically set swagger info
	docs.SwaggerInfo.Host = addr
	docs.SwaggerInfo.BasePath = BASEPATH
	if cert == nil {
		docs.SwaggerInfo.Schemes = []string{"http"}
	} else {
		docs.SwaggerInfo.Schemes = []string{"https"}
	}

	router := gin.Default()
	c := &controller{addr: addr, router: router}
	if err := c.Init(cert); err != nil {
		return nil, errors.Wrap(err, "cannot initialize rest controller")
	}
	return c, nil
}

type controller struct {
	server http.Server
	router *gin.Engine
	addr   string
}

func (ctrl *controller) Init(cert *tls.Certificate) error {
	var auth = func() gin.HandlerFunc {
		return func(c *gin.Context) {
			if len(c.GetHeader("Authorization")) == 0 {
				rest.NewResultMessage(c, http.StatusUnauthorized, errors.New("Authorization is required Header"))
				c.Abort()
			}
			c.Next()
		}
	}

	v1 := ctrl.router.Group(BASEPATH)
	v1.Use(auth())
	v1.PUT("/", ctrl.newMedia)
	ctrl.router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	var tlsConfig *tls.Config
	if cert != nil {
		tlsConfig = &tls.Config{
			Certificates: []tls.Certificate{*cert},
		}
	}
	ctrl.server = http.Server{
		Addr:      ctrl.addr,
		Handler:   ctrl.router,
		TLSConfig: tlsConfig,
	}
	return nil
}

func (ctrl *controller) Start(wg *sync.WaitGroup) {
	go func() {
		defer wg.Done() // let main know we are done cleaning up

		if ctrl.server.TLSConfig == nil {
			fmt.Printf("starting server at http://%s\n", ctrl.addr)
		} else {
			fmt.Printf("starting server at https://%s\n", ctrl.addr)
		}
		// always returns error. ErrServerClosed on graceful close
		if err := ctrl.server.ListenAndServe(); err != http.ErrServerClosed {
			// unexpected error. port in use?
			log.Errorf("server on '%s' ended: %v", ctrl.addr, err)
		}
	}()
}

func (ctrl *controller) Shutdown(ctx context.Context) error {
	return errors.WithStack(ctrl.server.Shutdown(ctx))
}

type NewMediaRequestBody struct {
	Collection string `json:"collection" example:"erara" format:"string"`
	Signature  string `json:"signature" example:"sig-4711" format:"string"`
	URN        string `json:"urn" example:"vfs://digispace/data/test.zip/image.tif" format:"string"`
}

// newMedia godoc
// @Summary      new media entry
// @Description  creates new media entry in database
// @Security 	 ApiKeyAuth
// @Tags         media
// @Accept       json
// @Produce      json
// @Param	     NewMediaRequest	body		NewMediaRequestBody	true	"Add new media"
// @Success      200  {object}  rest.HTTPResultMessage
// @Failure      400  {object}  rest.HTTPResultMessage
// @Failure      404  {object}  rest.HTTPResultMessage
// @Failure      500  {object}  rest.HTTPResultMessage
// @Router       / [put]
func (ctrl *controller) newMedia(c *gin.Context) {
	var requestBody NewMediaRequestBody
	if err := c.ShouldBindJSON(&requestBody); err != nil {
		rest.NewResultMessage(c, http.StatusBadRequest, err)
		return
	}
}
